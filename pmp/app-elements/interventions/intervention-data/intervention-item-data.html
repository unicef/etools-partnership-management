<link rel="import" href="../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../bower_components/etools-ajax/etools-ajax-request-behavior.html">
<link rel="import" href="../../../../bower_components/etools-behaviors/etools-logs-behavior.html">

<link rel="import" href="../../../app-config/app-dexie-db-config.html">
<link rel="import" href="../../../app-config/app-endpoints-behavior.html">
<link rel="import" href="../../../app-behaviors/ajax-server-errors-behavior.html">
<link rel="import"
      href="../../../app-elements/static-common-data/redux-behaviors/common-static-data-redux-behavior.html">

<dom-module id="intervention-item-data">

  <script>
    (function() {
      'use strict';
      Polymer({

        is: 'intervention-item-data',
        behaviors: [
          EtoolsAjaxRequestBehavior,
          EtoolsPmpApp.Behaviors.Endpoints,
          EtoolsLogsBehavior,
          EtoolsPmpApp.Behaviors.AjaxServerErrors,
          EtoolsPmpApp.Behaviors.EtoolsDataReduxStore
        ],
        properties: {
          pdEndpoints: {
            type: Object,
            value: {
              DETAILS: 'interventionDetails',
              CREATE: 'interventions',
              AGREEMENT_DETAILS: 'agreementDetails'
            }
          },
          intervention: {
            type: Object,
            readOnly: true,
            notify: true
          },
          originalIntervention: {
            type: Object
          },
          interventionId: {
            type: Number,
            notify: true,
            observer: '_interventionIdChanged'
          },

          handleResponseAdditionalCallback: Object,

          offices: {
            type: Array,
            statePath: 'offices'
          },
          sectors: {
            type: Array,
            statePath: 'sectors'
          },
          /**
           * ajaxLoadingMsgSource use is required for request errors handling in AjaxServerErrorsBehavior
           */
          ajaxLoadingMsgSource: {
            type: String,
            value: 'pd-ssfa-data'
          },
        },

        _triggerInterventionRequest: function(options) {
          let self = this;
          let ajaxMethod = options.method || 'GET';
          this.sendRequest(options).then(function(resp) {
            self._handleSuccResponse(resp, ajaxMethod);
          }).catch(function(error) {
            self._handleErrorResponse(error, ajaxMethod);
          });
        },

        _interventionIdChanged: function(newId) {
          if (newId) {
            this.fire('global-loading', {
              message: 'Loading PD/SSFA data...',
              active: true,
              loadingSource: this.ajaxLoadingMsgSource
            });
            this._triggerInterventionRequest({endpoint: this.getEndpoint(this.pdEndpoints.DETAILS, {id: newId})});
          }
        },

        _handleErrorResponse: function(response, ajaxMethod) {
          this.handleErrorResponse(response, ajaxMethod);
          this._restoreUnsuccessfullyDeletedFrs();
        },
        _restoreUnsuccessfullyDeletedFrs: function() {
          this.set('intervention.frs_details', this.originalIntervention.frs_details);
          this.set('intervention.frs', this.originalIntervention.frs);
        },
        /**
         * Handle received data from request
         */
        _handleSuccResponse: function(response, ajaxMethod) {
          response.original_sectors = JSON.parse(JSON.stringify(response.sector_locations));
          this._setIntervention(response);

          // call additional callback, if any
          if (typeof this.handleResponseAdditionalCallback === 'function') {
            this.handleResponseAdditionalCallback.bind(this, response)();
            // reset callback
            this.set('handleResponseAdditionalCallback', null);
          }

          let self = this;
          if (!ajaxMethod || ajaxMethod !== 'GET') {
            // update the interventions list in dexieDB
            let mappedResponse = this._formatResponseDataForDexie(response);
            EtoolsPmpApp.DexieDb.table('interventions').put(mappedResponse).then(function() {
              self.fire('reload-list');
            });

            if (response.document_type && response.document_type === 'SSFA' &&
                response.status !== 'draft') {
              this.sendRequest({
                endpoint: this.getEndpoint(this.pdEndpoints.AGREEMENT_DETAILS, {id: response.agreement})
              }).then(function(resp) {
                self.updateAgreeementStatus.bind(self, resp)();
              });
            }
          }
        },
        updateAgreeementStatus: function(agreement) {
          let minimalAgreement = this._getMinimalAgreementData(agreement);
          EtoolsPmpApp.DexieDb.table('agreements').put(minimalAgreement);
        },
        _getMinimalAgreementData: function(detail) {
          let minimalAgrData = {
            agreement_number: '',
            agreement_type: '',
            end: null,
            id: null,
            partner: null,
            partner_name: null,
            signed_by: null,
            signed_by_partner_date: null,
            signed_by_unicef_date: null,
            start: null,
            status: ''
          };
          let propName;
          for (propName in minimalAgrData) {
            if (!detail.hasOwnProperty(propName)) {
              this.logWarn('Mapping property not found');
            } else {
              minimalAgrData[propName] = detail[propName];
            }
          }
          return minimalAgrData;
        },

        _hasFiles: function(list, property) {
          if (!Array.isArray(list) || (Array.isArray(list) && list.length === 0)) {
            return false;
          }
          let hasF = false;
          let i;
          for (i = 0; i < list.length; i++) {
            if (list[i][property] instanceof File) {
              hasF = true;
            } else {
              delete list[i][property];
            }
          }
          return hasF;
        },
        _fileField: function(intervention, property) {
          return intervention[property] instanceof File;
        },

        /**
         * Update intervention status. In addition set a callback to be called after request is complete.
         */
        updateInterventionStatus: function(data, callback) {
          if (!data.interventionId) {
            this.fire('toast', {text: 'Invalid intervention ID', showCloseBtn: true});
          } else {
            if (['signed', 'suspended', 'terminated'].indexOf(data.status) > -1) {
              // status change is allowed
              // set additional callback if any
              if (callback) {
                this.set('handleResponseAdditionalCallback', callback);
              }
              this.fire('global-loading', {
                message: 'Changing intervention status...',
                active: true,
                loadingSource: this.ajaxLoadingMsgSource
              });
              // fire in the hole
              this._triggerInterventionRequest({
                method: 'PATCH',
                endpoint: this.getEndpoint(this.pdEndpoints.DETAILS, {id: data.interventionId}),
                body: {
                  status: data.status
                }
              });
            } else {
              this.fire('toast', {
                text: 'Changing status to \'' + data.status + '\' is not allowed!',
                showCloseBtn: true
              });
            }
          }
        },

        /**
         * Save intervention data
         */
        saveIntervention: function(intervention, callback) {
          if (intervention && typeof intervention === 'object' && Object.keys(intervention).length === 0) {
            this.fire('toast', {text: 'Invalid intervention data!', showCloseBtn: true});
          } else {
            let endpoint = null;
            let isNew = false;
            let prepareMultipartData = false;

            if (intervention.id) {
              // prepare PATCH endpoint
              endpoint = this.getEndpoint(this.pdEndpoints.DETAILS, {id: intervention.id});
            } else {
              // new intervention, use POST method for the same endpoint
              endpoint = this.getEndpoint(this.pdEndpoints.CREATE);
              isNew = true;
            }
            // remove id from data
            if (intervention.id) {
              delete intervention.id;
            }
            // set additional callback if any and only if is new intervention
            if (callback && isNew) {
              this.set('handleResponseAdditionalCallback', callback);
            }

            if (this._hasFiles(intervention.attachments, 'attachment')) {
              prepareMultipartData = true;
            }
            // check prc_review_document doc, if no file delete the property from the object
            if (this._fileField(intervention, 'prc_review_document')) {
              prepareMultipartData = true;
            } else {
              delete intervention.prc_review_document;
            }
            // check signed_pd_document doc, if no file delete the property from the object
            if (this._fileField(intervention, 'signed_pd_document')) {
              prepareMultipartData = true;
            } else {
              delete intervention.signed_pd_document;
            }

            if (this._hasFiles(intervention.amendments, 'signed_amendment')) {
              prepareMultipartData = true;
            }
            if (Array.isArray(intervention.sector_locations)) {
              intervention.sector_locations = intervention.sector_locations.filter(function(elem) {
                return elem.sector || (Array.isArray(elem.locations) && elem.locations.length);
              });
            }
            if (Array.isArray(intervention.result_links)) {
              intervention.result_links = intervention.result_links.filter(function(elem) {
                return elem.cp_output || (Array.isArray(elem.ram_indicators) && elem.ram_indicators.length);
              });
            }
            if (Array.isArray(intervention.planned_visits)) {
              intervention.planned_visits = intervention.planned_visits.filter(function(elem) {
                return elem.year || elem.programmatic;
              });
            }
            this.fire('global-loading', {
              message: 'Saving intervention data...',
              active: true,
              loadingSource: this.ajaxLoadingMsgSource
            });

            let method = (isNew) ? 'POST' : 'PATCH';
            this._triggerInterventionRequest({method: method, endpoint: endpoint, body: intervention,
              multiPart: prepareMultipartData, prepareMultipartData: prepareMultipartData});
          }
        },

        _formatResponseDataForDexie: function(responseDetail) {
          let dexieObject = {};
          dexieObject.sectors = [];
          dexieObject.cp_outputs = [];
          dexieObject.unicef_budget = 0;
          dexieObject.cso_contribution = 0;

          dexieObject.id = responseDetail.id;
          dexieObject.country_programme = responseDetail.country_programme;
          dexieObject.end = responseDetail.end;
          dexieObject.title = responseDetail.title;
          dexieObject.start = responseDetail.start;
          dexieObject.status = responseDetail.status;
          dexieObject.number = responseDetail.number;
          dexieObject.offices = responseDetail.offices;
          dexieObject.partner_name = responseDetail.partner;
          dexieObject.document_type = responseDetail.document_type;
          dexieObject.unicef_focal_points = responseDetail.unicef_focal_points;

          this._updatePlannedBudgetInfo(dexieObject, responseDetail);
          this._updateOffices(dexieObject, responseDetail);
          this._updateSectors(dexieObject, responseDetail);
          this._updateFrInfo(dexieObject, responseDetail.frs_details);

          responseDetail.result_links.forEach(function(elem) {
            dexieObject.cp_outputs.push(elem.cp_output);
          });

          return dexieObject;
        },

        _updatePlannedBudgetInfo: function(dexieObject, intervention) {
          dexieObject.unicef_budget = parseFloat(intervention.planned_budget.unicef_cash) +
              parseFloat(intervention.planned_budget.in_kind_amount);
          dexieObject.cso_contribution = parseFloat(intervention.planned_budget.partner_contribution);
          dexieObject.total_budget = parseFloat(intervention.planned_budget.total);
          dexieObject.unicef_cash = parseFloat(intervention.planned_budget.unicef_cash);
        },
        _updateFrInfo: function(dexieObject, intervFrDetails) {
          if (this._noFrOnIntervention(intervFrDetails)) {
            return;
          }
          dexieObject.frs_total_frs_amt = intervFrDetails.total_frs_amt;
          dexieObject.frs_latest_end_date = intervFrDetails.latest_end_date;
          dexieObject.frs_earliest_start_date = intervFrDetails.earliest_start_date;
        },
        _noFrOnIntervention: function(intervFrDetails) {
          return (!intervFrDetails || !intervFrDetails.earliest_start_date);
        },
        _updateOffices: function(dexieObject, responseDetail) {
          if (!responseDetail.offices || !responseDetail.offices.length) {
            dexieObject.offices_names = [];
            return;
          }

          dexieObject.offices_names = this._getSelectedOfficesNames(responseDetail);
        },
        _getSelectedOfficesNames: function(responseDetail) {
          let selectedOffices = this.offices.filter(function(office) {
            return responseDetail.offices.indexOf(office.id.toString()) > -1;
          });
          if (!selectedOffices) {
            return [];
          }
          return selectedOffices.map(function(office) {
            return office.name;
          });
        },
        _updateSectors: function(dexieObject, responseDetail) {
          if (!responseDetail.sector_locations || !responseDetail.sector_locations.length) {
            dexieObject.sectors = [];
            return;
          }
          dexieObject.sectors = this._getSelectedSectorsNames(responseDetail);
        },
        _getSelectedSectorsNames: function(responseDetail) {
          let selectedSectorIds = responseDetail.sector_locations.map(function(sl) {
            return (sl.sector && typeof sl.sector === 'object')
                ? sl.sector.id.toString()
                : sl.sector.toString();
          });
          let selectedSectors = this.sectors.filter(function(sector) {
            return selectedSectorIds.indexOf(sector.id.toString()) > -1;
          });
          if (!selectedSectors) {
            return [];
          }
          return selectedSectors.map(function(s) {
            return s.name;
          });
        }

      });
    })();
  </script>

</dom-module>
