<link rel="import" href="../../../bower_components/etools-ajax/etools-ajax-request-mixin.html">
<link rel="import" href="../scripts/lodash.html">
<link rel="import" href="../config/config.html">
<link rel="import" href="../redux/etools-data-redux-store.html">
<link rel="import" href="endpoints.html">

<script>
  'use strict';

  window.EtoolsPmpApp = window.EtoolsPmpApp || {};
  window.EtoolsPmpApp.Mixins = window.EtoolsPmpApp.Mixins || {};

  /**
   * PMP endpoints functionality
   * @polymer
   * @mixinFunction
   * @appliesMixin EtoolsAjaxRequestMixin
   * @appliesMixin EtoolsPmpApp.Mixins.EtoolsDataReduxStore
   */
  EtoolsPmpApp.Mixins.Endpoints = Polymer.dedupingMixin(
      (superClass) => class extends EtoolsAjaxRequestMixin(EtoolsPmpApp.Mixins.EtoolsDataReduxStore(superClass)) {
    static get properties() {
      return {
        prpCountries: {
          type: Array,
          statePath: 'PRPCountryData'
        },
        currentUser: {
          type: Object,
          statePath: 'currentUser'
        }
      };
    }

    _getPrpCountryId() {
      let self = this;
      let currentCountry = this.currentUser.countries_available.find(function(country) {
        return country.id === self.currentUser.country.id;
      });
      let prpCountry = self.prpCountries.find(function(prpCountry) {
        return prpCountry.business_area_code === currentCountry.business_area_code;
      });

      if (!prpCountry) {
        let countryNotFoundInPrpWarning = 'Error: ' + this.currentUser.country.name + ' country data was ' +
            'not found in the available PRP countries by business_area_code!';
        throw new Error(countryNotFoundInPrpWarning);
      }

      return prpCountry.id;
    }

    _urlTemplateHasCountryId(template) {
      return template.indexOf('<%=countryId%>') > -1;
    }

    getEndpoint(endpointName, data) {
      let endpoint = JSON.parse(JSON.stringify(EtoolsPmpApp.Endpoints[endpointName]));
      let authorizationTokenMustBeAdded = this.authorizationTokenMustBeAdded(endpoint);
      let baseSite = authorizationTokenMustBeAdded
          ? EtoolsPmpApp.Config.endpointsDomainConfig.tokenEndpointsHost[endpoint.token]
          : EtoolsPmpApp.Config.baseSite;

      if (this._hasUrlTemplate(endpoint)) {
        if (data && authorizationTokenMustBeAdded && this._urlTemplateHasCountryId(endpoint.template)) {
          // we need to get corresponding PRP country ID
          data.countryId = this._getPrpCountryId();
        }
        endpoint.url = baseSite + _.template(endpoint.template)(data);
      } else {
        if (endpoint.url.indexOf(baseSite) === -1) {
          endpoint.url = baseSite + endpoint.url;
        }
      }

      return endpoint;
    }

    _hasUrlTemplate(endpoint) {
      return endpoint && endpoint.hasOwnProperty('template') && endpoint.template !== '';
    }

    _getDeferrer() {
      // create defer object (utils behavior contains to many other unneeded methods to be used)
      let defer = {};
      defer.promise = new Promise(function(resolve, reject) {
        defer.resolve = resolve;
        defer.reject = reject;
      });
      return defer;
    }

    authorizationTokenMustBeAdded(endpoint) {
      return endpoint && ('token' in endpoint);
    }

    getCurrentToken(tokenKey) {
      return localStorage.getItem(EtoolsPmpApp.Config.endpointsDomainConfig.tokenStorageKeys[tokenKey]);
    }

    storeToken(tokenKey, tokenBase64Encoded) {
      localStorage.setItem(EtoolsPmpApp.Config.endpointsDomainConfig.tokenStorageKeys[tokenKey], tokenBase64Encoded);
    }

    decodeBase64Token(encodedToken) {
      let base64Url = encodedToken.split('.')[1];
      let base64 = base64Url.replace('-', '+').replace('_', '/');
      return JSON.parse(window.atob(base64));
    }

    tokenIsValid(token) {
      let decodedToken = this.decodeBase64Token(token);
      return Date.now() < decodedToken.exp;
    }

    getAuthorizationHeader(token) {
      return {'Authorization': 'JWT ' + token};
    }

    requestToken(endpoint) {
      return this.sendRequest({
        endpoint: endpoint
      });
    }

    _buildOptionsWithTokenHeader(options, token) {
      options.headers = this.getAuthorizationHeader(token);
      delete options.endpoint.token; // cleanup token from endpoint object
      return options;
    }

    getTokenEndpointName(tokenKey) {
      return EtoolsPmpApp.Config.endpointsDomainConfig.getTokenEndpoints[tokenKey];
    }

    addTokenToRequestOptions(endpointName, data) {
      let options = {};
      try {
        options.endpoint = this.getEndpoint(endpointName, data);
      } catch (e) {
        return Promise.reject(e);
      }

      // create defer object (utils behavior contains to many other unneeded methods to be used)
      let defer = this._getDeferrer();

      if (this.authorizationTokenMustBeAdded(options.endpoint)) {
        let tokenKey = options.endpoint.token;
        let token = this.getCurrentToken(tokenKey);
        // because we could have other tokens too
        if (token && this.tokenIsValid(token)) {
          // token exists and it's still valid
          options = this._buildOptionsWithTokenHeader(options, token);
          defer.resolve(options);
        } else {
          // request new token
          let self = this;
          let tokenEndpointName = this.getTokenEndpointName(tokenKey);
          this.requestToken(this.getEndpoint(tokenEndpointName)).then(function(response) {
            self.storeToken(options.endpoint.token, response.token);
            options = self._buildOptionsWithTokenHeader(options, response.token);
            defer.resolve(options);
          }).catch(function(error) {
            // request for getting a new token failed
            defer.reject(error);
          });
        }
      } else {
        defer.resolve(options);
      }
      return defer.promise;
    }

    _addAdditionalRequestOptions(options, requestAdditionalOptions) {
      if (!_.isEmpty(requestAdditionalOptions)) {
        Object.keys(requestAdditionalOptions).forEach(function(key) {
          switch (key) {
            case 'endpoint':
              break;
            case 'headers':
              // add additional headers
              options.headers = Object.assign({}, options.headers, requestAdditionalOptions[key]);
              break;
            default:
              options[key] = requestAdditionalOptions[key];
          }
        });
      }
      return options;
    }

    fireRequest(endpoint, endpointTemplateData, requestAdditionalOptions, activeReqKey) {
      if (!endpoint) {
        this.logError('Endpoint name is missing.', 'Endpoints:fireRequest');
        return;
      }
      let defer = this._getDeferrer();
      let self = this;
      this.addTokenToRequestOptions(endpoint, endpointTemplateData)
          .then(function(requestOptions) {
            let options = self._addAdditionalRequestOptions(requestOptions, requestAdditionalOptions);
            return self.sendRequest(options, activeReqKey);
          })
          .then(function(endpointResponse) {
            defer.resolve(endpointResponse);
          })
          .catch(function(error) {
            defer.reject(error);
          });
      return defer.promise;
    }

  });

</script>
