<link rel="import" href="../../bower_components/etools-ajax/etools-ajax-request-behavior.html">
<link rel="import" href="../../scripts/lodash/lodash.html">
<link rel="import" href="app-config.html">
<link rel="import" href="app-endpoints.html">

<script>
  /**
   * PMP app endpoints list.
   */
  window.EtoolsPmpApp = window.EtoolsPmpApp || {};
  window.EtoolsPmpApp.Behaviors = window.EtoolsPmpApp.Behaviors || {};

  EtoolsPmpApp.EndpointConfig = {
    tokenEndpointsHost: {
      prp: 'http://127.0.0.1:8080',
      // prp: 'https://etools-test.unicef.org',
    },
    tokenStorageKeys: {
      prp: 'etoolsPrpToken'
    },
    getTokenEndpoints: {
      prp: 'prpToken'
    }
  };

  /** @polymerBehavior EtoolsPmpApp.Behaviors.EndpointsImpl */
  EtoolsPmpApp.Behaviors.EndpointsImpl = {

    getEndpoint: function(endpointName, data) {
      let endpoint = JSON.parse(JSON.stringify(EtoolsPmpApp.Endpoints[endpointName]));
      let baseSite = this.authorizationTokenMustBeAdded(endpoint)
          ? EtoolsPmpApp.EndpointConfig.tokenEndpointsHost[endpoint.token]
          : EtoolsPmpApp.Config.baseSite;

      if (this._hasUrlTemplate(endpoint)) {
        endpoint.url = baseSite + _.template(endpoint.template)(data);
      } else {
        if (endpoint.url.indexOf(baseSite) === -1) {
          endpoint.url = baseSite + endpoint.url;
        }
      }

      return endpoint;
    },

    _hasUrlTemplate: function(endpoint) {
      return endpoint && endpoint.hasOwnProperty('template') && endpoint.template !== '';
    },

    _getDeferrer: function() {
      // create defer object (utils behavior contains to many other unneeded methods to be used)
      let defer = {};
      defer.promise = new Promise(function(resolve, reject) {
        defer.resolve = resolve;
        defer.reject = reject;
      });
      return defer;
    },

    authorizationTokenMustBeAdded: function(endpoint) {
      return endpoint && ('token' in endpoint);
    },

    getCurrentToken: function(tokenKey) {
      return localStorage.getItem(EtoolsPmpApp.EndpointConfig.tokenStorageKeys[tokenKey]);
    },

    storeToken: function(tokenKey, tokenBase64Encoded) {
      localStorage.setItem(EtoolsPmpApp.EndpointConfig.tokenStorageKeys[tokenKey], tokenBase64Encoded);
    },

    decodeBase64Token: function(encodedToken) {
      let base64Url = encodedToken.split('.')[1];
      let base64 = base64Url.replace('-', '+').replace('_', '/');
      return JSON.parse(window.atob(base64));
    },

    tokenIsValid: function(token) {
      let decodedToken = this.decodeBase64Token(token);
      return Date.now() < decodedToken.exp;
    },

    getAuthorizationHeader: function(token) {
      return {'Authorization': 'JWT ' + token};
    },

    requestToken: function(endpoint) {
      return this.sendRequest({
        endpoint: endpoint
      });
    },

    _buildOptionsWithTokenHeader: function(options, token) {
      options.headers = this.getAuthorizationHeader(token);
      delete options.endpoint.token; // cleanup token from endpoint object
      return options;
    },

    getTokenEndpointName: function(tokenKey) {
      return EtoolsPmpApp.EndpointConfig.getTokenEndpoints[tokenKey];
    },

    addTokenToRequestOptions: function(endpointName, data) {
      let options = {
        endpoint: this.getEndpoint(endpointName, data)
      };

      // create defer object (utils behavior contains to many other unneeded methods to be used)
      let defer = this._getDeferrer();

      if (this.authorizationTokenMustBeAdded(options.endpoint)) {
        let tokenKey = options.endpoint.token;
        let token = this.getCurrentToken(tokenKey);
        // because we could have other tokens too
        if (token && this.tokenIsValid(token)) {
          // token exists and it's still valid
          options = this._buildOptionsWithTokenHeader(options, token);
          defer.resolve(options);
        } else {
          // request new token
          let self = this;
          let tokenEndpointName = this.getTokenEndpointName(tokenKey);
          this.requestToken(this.getEndpoint(tokenEndpointName)).then(function(response) {
            self.storeToken(options.endpoint.token, response.token);
            options = self._buildOptionsWithTokenHeader(options, response.token);
            defer.resolve(options);
          }).catch(function(error) {
            // request for getting a new token failed
            defer.reject(error);
          });
        }
      } else {
        defer.resolve(options);
      }
      return defer.promise;
    },

    _addAdditionalRequestOptions: function(options, requestAdditionalOptions) {
      if (!_.isEmpty(requestAdditionalOptions)) {
        Object.keys(requestAdditionalOptions).forEach(function(key) {
          switch (key) {
            case 'endpoint':
              break;
            case 'headers':
              // add additional headers
              options.headers = Object.assign({}, options.headers, requestAdditionalOptions[key]);
              break;
            default:
              options[key] = requestAdditionalOptions[key];
          }
        });
      }
      return options;
    },

    fireRequest: function(endpoint, endpointTemplateData, requestAdditionalOptions) {
      if (!endpoint) {
        this.logError('Endpoint name is missing.', 'Endpoints:fireRequest');
        return;
      }
      let defer = this._getDeferrer();
      let self = this;
      this.addTokenToRequestOptions(endpoint, endpointTemplateData)
          .then(function(requestOptions) {
            let options = self._addAdditionalRequestOptions(requestOptions, requestAdditionalOptions);
            return self.sendRequest(options);
          })
          .then(function(endpointResponse) {
            defer.resolve(endpointResponse);
          })
          .catch(function(error) {
            defer.reject(error);
          });
      return defer.promise;
    }
  };

  /** @polymerBehavior EtoolsPmpApp.Behaviors.Endpoints */
  EtoolsPmpApp.Behaviors.Endpoints = [
    EtoolsAjaxRequestBehavior,
    EtoolsPmpApp.Behaviors.EndpointsImpl
  ];

</script>
